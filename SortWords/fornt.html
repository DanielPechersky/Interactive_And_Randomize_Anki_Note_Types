<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Word Sort Game</title>
<!-- CSS is assumed to be in an external file or <style> block -->

</head>
<body>
<!-- Hidden field containing the data structure -->
<p id="words" style="display: none;">{{Words}}</p>

<h1>{{Title}}</h1>

<div class="game-container">
    <!-- Word Bank: Initial source and return location for words -->
    <div id="word-bank" class="word-bank drop-zone" data-category="source">
        <h2>Available Items (Drag these):</h2>
    </div>

    <!-- Category Columns: Drop targets for sorting -->
    <div id="columns-container" class="columns-container">
        <!-- Columns will be generated by JavaScript -->
    </div>

    <!-- Button Container (Initially hidden on front, shown on back) -->
    <div class="button-controls" style="display: none;">
        <button id="check-button">Check Answers</button>
        <button id="show-answer-button">Show Answer</button>
    </div>

    <!-- Results Area (Initially hidden on front, shown on back) -->
    <div id="results" style="display: none;"></div>
</div>

<script>
(()=>{ // IIFE to avoid polluting global scope

// --- Core Setup ---
const isFront = document.getElementById("back") == null; // Heuristic to check if it's the Anki front card
const wordStateStorageKey = "sortWordsState"; // State of word placements
const columnOrderStorageKey = "sortWordsColumnOrder"; // Order of columns displayed
console.log(`Script running. isFront = ${isFront}`);

// --- DOM Element References ---
const inputElement = document.getElementById("words");
const wordBank = document.getElementById('word-bank');
const columnsContainer = document.getElementById('columns-container');
const checkButton = document.getElementById('check-button');
const showAnswerButton = document.getElementById('show-answer-button');
const resultsDiv = document.getElementById('results');
const buttonControlsDiv = document.querySelector('.button-controls');

// --- Game Data Structures ---
let gameData = []; // Holds { category: string, words: string[] } parsed from input
let allWords = []; // Holds { id: string, text: string, category: string } derived from gameData

// --- UI Visibility based on Front/Back ---
if (isFront) {
    console.log("FRONT SIDE: Hiding controls/results.");
    if (buttonControlsDiv) buttonControlsDiv.style.display = 'none';
    if (resultsDiv) resultsDiv.style.display = 'none';
    // Clear previous state ONLY on the front side to start fresh
    // localStorage.removeItem(wordStateStorageKey); // Let's keep state unless explicitly reset
    // localStorage.removeItem(columnOrderStorageKey); // Column order should be set fresh on front
} else {
    console.log("BACK SIDE: Showing controls/results.");
    if (buttonControlsDiv) buttonControlsDiv.style.display = ''; // Use default display (block, flex, etc.)
    if (resultsDiv) resultsDiv.style.display = ''; // Use default display
}

// --- Auto-scroll variables ---
const scrollThreshold = 80; // Pixels from edge to trigger scroll
const scrollStep = 10; // Pixels to scroll per frame
let scrollIntervalId = null;
let currentScrollDirection = null;

// --- Parsing Function (Handles HTML content in words) ---
function parseInputString(input) {
    if (!input || typeof input !== 'string') return [];
    const categories = [];
    // Split by closing bracket, optional comma, and whitespace
    const categoryBlocks = input.trim().split(/\]\s*,?\s*/).filter(block => block.trim() !== '');

    categoryBlocks.forEach((block) => {
        // Ensure block ends with ']' if split removed it
        let currentBlock = block.trim();
        // Check if the block seems incomplete (doesn't start with category name or lacks '[')
        if (!currentBlock.includes('[') && !currentBlock.endsWith(']')) {
            // This might be a leftover part from split, try to find start or ignore
             console.warn("Skipping potentially incomplete block:", currentBlock);
             return; // Skip this potentially malformed block part
        }
        if (!currentBlock.endsWith(']')) currentBlock += ']';


        const categoryMatch = currentBlock.match(/^([^[]+)/); // Match text before '['
        const wordsMatch = currentBlock.match(/\[(.*?)\]/s); // Match text inside '[]', 's' flag for multiline

        if (categoryMatch && wordsMatch) {
            // Preserve category case for display
            const categoryName = categoryMatch[1].trim();
            const contentInsideBrackets = wordsMatch[1].trim();

            // Advanced splitting to handle HTML tags containing commas
            const words = [];
            let currentWord = '';
            let inTag = false;
            for (let i = 0; i < contentInsideBrackets.length; i++) {
                const char = contentInsideBrackets[i];
                // Basic check for tag start/end
                if (char === '<') {
                    // Avoid issues with '<' used as text; check if it looks like a tag start
                     if (i + 1 < contentInsideBrackets.length && contentInsideBrackets[i+1].match(/[a-zA-Z/?!]/)) {
                        inTag = true;
                     }
                }
                if (char === '>') inTag = false;

                if (char === ',' && !inTag) {
                    // Found a delimiter comma outside a tag
                    const trimmedWord = currentWord.trim();
                    if (trimmedWord) words.push(trimmedWord);
                    currentWord = '';
                } else {
                    currentWord += char;
                }
            }
            // Add the last word after the loop
            const lastTrimmedWord = currentWord.trim();
            if (lastTrimmedWord) words.push(lastTrimmedWord);

            // Basic validation: Check if any word seems like an unclosed tag
            const potentiallyMalformed = words.some(w => {
                const openCount = (w.match(/</g) || []).length;
                const closeCount = (w.match(/>/g) || []).length;
                // Crude check: if more opens than closes, or if it starts with < but doesn't end with >
                return openCount > closeCount || (w.startsWith('<') && !w.endsWith('>'));
            });
            if (potentiallyMalformed) {
                 console.warn(`Potential malformed HTML detected after parsing category '${categoryName}'. Check commas within tags/attributes. Parsed items:`, words);
            }

            if (categoryName && words.length > 0) {
                // Store category with original case
                 categories.push({ category: categoryName, words: words });
            } else {
                console.warn("Parsed block but category name or words were empty:", currentBlock);
            }
        } else {
            console.error("Could not parse category/words from block:", currentBlock);
        }
    });
    return categories;
}


// --- Shuffle Function ---
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

// --- Initialize Game ---
function initGame() {
    console.log("Initializing game...");
    // Reset existing elements
    wordBank.innerHTML = '<h2>Available Items (Drag these):</h2>'; // Reset word bank content
    columnsContainer.innerHTML = ''; // Clear old columns
    if(resultsDiv) resultsDiv.textContent = ''; // Clear results text
    if(resultsDiv) resultsDiv.style.color = ""; // Reset result color styling
    allWords = []; // Reset internal word list

    // Get input string from the hidden element
    const rawInputString = inputElement?.innerHTML || "";
    gameData = parseInputString(rawInputString);

    if (!gameData || gameData.length === 0) {
        console.error("Game initialization failed: No valid game data from input:", rawInputString);
         if (!isFront && resultsDiv) { // Only show error message on the back
             resultsDiv.textContent = "Error: Could not parse input data or no categories found.";
             resultsDiv.style.color = "var(--clr-results-error, red)";
         }
        // Ensure buttons are disabled if game setup failed
        if(checkButton) checkButton.disabled = true;
        if(showAnswerButton) showAnswerButton.disabled = true;
        return; // Stop initialization
    }

    // --- Create word objects with stable IDs ---
    let wordIndex = 0;
    gameData.forEach(cat => {
        // Sanitize category name for ID once per category
        const safeCat = cat.category.replace(/[^a-zA-Z0-9-_]/g, ''); // Sanitize for use in ID
        cat.words.forEach(wordText => {
            // Create a unique, stable ID based on sanitized category and index.
            const wordId = `word-${safeCat}-${wordIndex}`; // ID uses index for stability
            allWords.push({
                id: wordId,
                text: wordText, // Keep original text (potentially HTML)
                category: cat.category // Store original case category name
            });
            wordIndex++;
        });
    });

    // --- Handle Column Order ---
    let columnOrder = gameData.map(cat => cat.category); // Default order from parsed data

    if (isFront) {
        // FRONT: Shuffle the category order AND save it
        shuffleArray(gameData); // Shuffle the gameData array itself to shuffle column order
        columnOrder = gameData.map(cat => cat.category); // Get the new shuffled order
        try {
            localStorage.setItem(columnOrderStorageKey, JSON.stringify(columnOrder));
            console.log("Saved shuffled column order:", columnOrder);
        } catch (e) {
            console.error("Failed to save column order to localStorage:", e);
        }
    } else {
        // BACK: Try to load the order saved by the front
        const savedOrderJSON = localStorage.getItem(columnOrderStorageKey);
        if (savedOrderJSON) {
            try {
                const savedOrder = JSON.parse(savedOrderJSON);
                // Verify the loaded order contains the same categories (case-sensitive) as gameData
                const currentCategories = new Set(gameData.map(cat => cat.category));
                const savedCategories = new Set(savedOrder);
                if (savedOrder.length === gameData.length && [...currentCategories].every(cat => savedCategories.has(cat))) {
                    console.log("Loaded column order from storage:", savedOrder);
                    // Re-sort gameData based on the loaded order
                    gameData.sort((a, b) => savedOrder.indexOf(a.category) - savedOrder.indexOf(b.category));
                    columnOrder = savedOrder; // Use the loaded order
                } else {
                    console.warn("Saved column order mismatch or invalid. Using default/parsed order.");
                    // Keep the order from parsing if loaded is invalid
                    columnOrder = gameData.map(cat => cat.category);
                }
            } catch (e) {
                console.error("Failed to parse saved column order. Using default/parsed order.", e);
                // Keep the order from parsing on error
                 columnOrder = gameData.map(cat => cat.category);
            }
        } else {
            console.log("No saved column order found. Using default/parsed order.");
            // Use the order determined by parsing if none saved (already in gameData)
            columnOrder = gameData.map(cat => cat.category);
        }
    }
    // Now gameData array is sorted according to the desired column order for creating columns

    // --- Create word elements (add all to word bank initially) ---
    const wordsForBank = [...allWords]; // Create a copy
    shuffleArray(wordsForBank); // Shuffle the visual order in the bank for randomness

    wordsForBank.forEach((wordObj) => {
        const wordEl = document.createElement('div');
        wordEl.id = wordObj.id; // Use the stable generated ID
        wordEl.classList.add('word-item');
        wordEl.innerHTML = wordObj.text; // Use innerHTML to render potential HTML content
        wordEl.draggable = true;
        wordEl.dataset.correctCategory = wordObj.category; // Store correct category (original case)
        wordEl.addEventListener('dragstart', handleDragStart);
        wordEl.addEventListener('dragend', handleDragEnd);
        wordBank.appendChild(wordEl);
    });

    // --- Create category columns based on the (potentially loaded/sorted) gameData ---
    gameData.forEach(catData => { // Iterate using the now-sorted gameData
        const columnEl = document.createElement('div');
        columnEl.classList.add('category-column');

        const headerEl = document.createElement('div');
        headerEl.classList.add('column-header');
        headerEl.textContent = catData.category; // Use category name with original case
        columnEl.appendChild(headerEl);

        const dropZoneEl = document.createElement('div');
        dropZoneEl.classList.add('drop-zone');
        dropZoneEl.dataset.category = catData.category; // Link drop zone to category (original case)
        columnEl.appendChild(dropZoneEl);

        // Add drop zone event listeners
        dropZoneEl.addEventListener('dragover', handleDragOver);
        dropZoneEl.addEventListener('dragleave', handleDragLeave);
        dropZoneEl.addEventListener('drop', handleDrop);

        columnsContainer.appendChild(columnEl);
    });

    // --- Add listeners to word bank (as a drop target) ---
    wordBank.addEventListener('dragover', handleDragOver);
    wordBank.addEventListener('dragleave', handleDragLeave);
    wordBank.addEventListener('drop', handleDrop);

    // --- Enable buttons ONLY if on the back side ---
    if (!isFront) {
       if(checkButton) checkButton.disabled = false;
       if(showAnswerButton) showAnswerButton.disabled = false;
    } else {
       // Ensure they are disabled if on front
       if(checkButton) checkButton.disabled = true;
       if(showAnswerButton) showAnswerButton.disabled = true;
    }
    console.log("Game initialization complete.");
}


// --- Drag Handlers ---
function handleDragStart(e) {
    // Ensure we are dragging a word-item
    if (e.target && e.target.classList.contains('word-item')) {
        e.dataTransfer.setData('text/plain', e.target.id); // Use the element's stable ID
        setTimeout(() => { e.target.classList.add('dragging'); }, 0); // Style change needs timeout
        e.dataTransfer.effectAllowed = 'move';
    } else {
        e.preventDefault(); // Prevent dragging unintended elements within word-item
    }
}

function handleDragEnd(e) {
    if (e.target && e.target.classList.contains('word-item')) {
        e.target.classList.remove('dragging');
    }
    stopScrolling(); // Stop auto-scroll when drag ends
}

function handleDragOver(e) {
    e.preventDefault(); // Necessary to allow dropping
    const dropZone = e.target.closest('.drop-zone');
    if (dropZone) {
        dropZone.classList.add('drag-over'); // Highlight potential drop target
        e.dataTransfer.dropEffect = 'move';

        // Handle auto-scrolling during drag over
        const clientY = e.clientY;
        const windowHeight = window.innerHeight;
        if (clientY > windowHeight - scrollThreshold) {
            if (currentScrollDirection !== 'down') { stopScrolling(); startScrolling('down'); }
        } else if (clientY < scrollThreshold) {
            if (currentScrollDirection !== 'up') { stopScrolling(); startScrolling('up'); }
        } else {
            stopScrolling();
        }
    } else {
         e.dataTransfer.dropEffect = 'none'; // Prevent dropping outside designated zones
    }
}

function handleDragLeave(e) {
    const dropZone = e.target.closest('.drop-zone');
    // Only remove highlight if leaving the zone element itself or moving to a non-child element
    if (dropZone && !dropZone.contains(e.relatedTarget)) {
        dropZone.classList.remove('drag-over');
    }
    // If cursor leaves window or goes over non-droppable area, ensure highlight is removed and scrolling stops
    if (!e.relatedTarget || !e.relatedTarget.closest('.drop-zone')) {
       document.querySelectorAll('.drop-zone.drag-over').forEach(zone => zone.classList.remove('drag-over'));
        stopScrolling(); // Also stop scrolling if cursor leaves valid drop areas
    }
}


function handleDrop(e) {
    console.log("Drop event triggered.");
    e.preventDefault();
    stopScrolling(); // Stop auto-scroll after drop attempt
    const dropZone = e.target.closest('.drop-zone');

    // Clean up highlights from all zones
    document.querySelectorAll('.drop-zone.drag-over').forEach(zone => zone.classList.remove('drag-over'));

    if (!dropZone) {
        console.log("Drop outside valid zone.");
        return; // Exit if not dropped in a valid zone
    }
    console.log(`Drop target zone category: ${dropZone.dataset.category}`);

    const draggedElementId = e.dataTransfer.getData('text/plain');
    const draggedElement = document.getElementById(draggedElementId); // Get element by ID

    if (draggedElement && dropZone) {
        console.log(`Attempting to drop element "${draggedElementId}" into zone "${dropZone.dataset.category}"`);
        // Check if the element is not already in this exact drop zone
        if (draggedElement.parentElement !== dropZone) {
             dropZone.appendChild(draggedElement); // Move the element
             console.log(` -> Element moved successfully.`);

             // Clear results/highlights ONLY if interaction happens on the back side
             if (!isFront) {
                 if(resultsDiv) resultsDiv.textContent = '';
                 if(resultsDiv) resultsDiv.style.color = ""; // Reset color
                 clearHighlights();
                 if(checkButton) checkButton.disabled = false; // Re-enable check button after interaction
                 if(showAnswerButton) showAnswerButton.disabled = false; // Re-enable show answer button
             }

             // --- ALWAYS SAVE WORD PLACEMENT STATE AFTER A SUCCESSFUL DROP ---
             console.log(" -> Saving word placement state...");
             saveWordPlacementState(); // Save state regardless of front/back

        } else {
            console.log(" -> Drop ignored: element already in this zone.");
        }

        // Optional: Scroll window if dropped into a category column (not the source bank)
        // if (dropZone.dataset.category !== 'source') {
        //     window.scrollTo({ top: 0, behavior: 'smooth' });
        // }

    } else {
         console.log("Drop failed. Element or Zone not found/valid. Element ID:", draggedElementId, "Element found:", !!draggedElement, "Zone found:", !!dropZone);
    }
}


// --- Check/Clear/Show Answers Logic ---
function checkAnswers() {
    if (isFront) { console.log("Check Answers ignored on front."); return; } // Guard
    if (!resultsDiv) { console.error("Results div not found."); return; } // Guard
    console.log("Checking answers...");

    clearHighlights(); // Clear previous styling first
    let allCorrect = true;
    let itemsPlacedInCategory = 0;
    const totalWords = allWords.length;

    // Check words within category columns
    const categoryDropZones = document.querySelectorAll('.columns-container .drop-zone');
    categoryDropZones.forEach(zone => {
        const columnCategory = zone.dataset.category; // Original case category name
        const wordsInZone = zone.querySelectorAll('.word-item');
        wordsInZone.forEach(wordEl => {
            itemsPlacedInCategory++;
            const correctCategory = wordEl.dataset.correctCategory; // Original case correct category
            // Direct comparison (case-sensitive)
            if (correctCategory === columnCategory) {
                wordEl.classList.add('correct');
            } else {
                wordEl.classList.add('incorrect');
                allCorrect = false; // Mark as incorrect if any word is misplaced
            }
        });
    });

    // Check words remaining in the word bank (these are unplaced/incorrect)
    const wordsInBank = wordBank.querySelectorAll('.word-item');
    if (wordsInBank.length > 0) {
        allCorrect = false; // Unplaced words mean not all correct
        wordsInBank.forEach(wordEl => {
            wordEl.classList.add('incorrect'); // Mark unplaced words as incorrect
        });
    }

    // Determine result message
    if (itemsPlacedInCategory === 0 && wordsInBank.length === totalWords) {
        resultsDiv.textContent = "Drag items from the bank into the category columns first!";
        resultsDiv.style.color = "var(--clr-results-info, blue)";
    } else if (allCorrect && itemsPlacedInCategory === totalWords) {
        resultsDiv.textContent = "Congratulations! All items are sorted correctly!";
        resultsDiv.style.color = "var(--clr-results-success, green)";
         // Optional: disable buttons after success
         // if(checkButton) checkButton.disabled = true;
         // if(showAnswerButton) showAnswerButton.disabled = true;
    } else {
        resultsDiv.textContent = "Some items are in the wrong place or haven't been placed. Keep trying!";
        resultsDiv.style.color = "var(--clr-results-error, red)";
        if (itemsPlacedInCategory < totalWords && wordsInBank.length > 0) {
            resultsDiv.textContent += ` (${wordsInBank.length} item${wordsInBank.length > 1 ? 's' : ''} still in the bank!)`;
        }
    }
    resultsDiv.style.display = ''; // Make sure results are visible
    console.log("Check complete. Result:", resultsDiv.textContent);
}

function clearHighlights() {
    // Safe to run on front or back, just removes CSS classes
    const allWordItems = document.querySelectorAll('.word-item');
    allWordItems.forEach(item => {
        item.classList.remove('correct', 'incorrect');
    });
    // Only clear text content if resultsDiv exists and is potentially visible (back side)
    if (!isFront && resultsDiv) {
        resultsDiv.textContent = '';
        resultsDiv.style.color = ""; // Reset color
        // resultsDiv.style.display = 'none'; // Optionally hide results again until next check/show
    }
}

function showAnswers() {
    if (isFront) { console.log("Show Answers ignored on front."); return; } // Guard
    if (!resultsDiv) { console.error("Results div not found."); return; } // Guard
    console.log("Showing answers...");

    clearHighlights(); // Clear any previous check results
    resultsDiv.textContent = "Showing the correct placement. Any further edits won't be saved until the card is reviewed again.";
    resultsDiv.style.color = "var(--clr-results-info, blue)";
    resultsDiv.style.display = ''; // Ensure results area is visible

    // Move each word element to its correct category's drop zone
    const allWordElements = document.querySelectorAll('.word-item'); // Get all word elements from anywhere
    allWordElements.forEach(wordEl => {
        const correctCategory = wordEl.dataset.correctCategory; // Original case
        // Find target drop zone using the original case category name
        const targetDropZone = document.querySelector(`.columns-container .drop-zone[data-category="${correctCategory}"]`);

        if (targetDropZone) {
            // Move element only if it's not already there
            if (wordEl.parentElement !== targetDropZone) {
                 targetDropZone.appendChild(wordEl);
            }
        } else {
            // Fallback: If the correct category column doesn't exist (shouldn't happen), move to word bank
            console.warn(`Could not find drop zone for category: ${correctCategory}. Moving item "${wordEl.id}" to word bank.`);
            if (wordEl.parentElement !== wordBank) {
                 wordBank.appendChild(wordEl);
            }
        }
    });

    // Disable buttons after showing the answer
    if(showAnswerButton) showAnswerButton.disabled = true;
    if(checkButton) checkButton.disabled = true; // Also disable check button

    // Clear saved state when answers are shown, forcing a fresh start next time
    console.log("Clearing saved word placement state because answers shown.");
    localStorage.removeItem(wordStateStorageKey);
    // Keep column order state - it doesn't change when showing answers, and is needed if user flips back/forth.

    console.log("Show answers complete.");
}


// --- Auto-Scroll Functions ---
function startScrolling(direction) {
    if (scrollIntervalId !== null) return; // Already scrolling
    currentScrollDirection = direction;
    console.log("Starting scroll:", direction);

    function scrollLoop() {
        if (!currentScrollDirection) { // Check if scrolling was stopped
            stopScrolling(); // Ensure cancellation if flag is cleared elsewhere
            return;
        }
        let scrollAmount = (currentScrollDirection === 'down') ? scrollStep : -scrollStep;
        window.scrollBy(0, scrollAmount);
        // Continue animation frame loop only if still active
        scrollIntervalId = requestAnimationFrame(scrollLoop);
    }
    // Start the animation frame loop
    scrollIntervalId = requestAnimationFrame(scrollLoop);
}

function stopScrolling() {
    if (scrollIntervalId !== null) {
        console.log("Stopping scroll.");
        cancelAnimationFrame(scrollIntervalId);
        scrollIntervalId = null;
    }
    currentScrollDirection = null; // Clear direction regardless
}

// --- Save/Load Game State (Word Placements) ---

function saveWordPlacementState() {
    // Saves the category ('source' or column category name) for each word item ID.
    // Column order is saved separately in initGame (on front side).
    console.log("--- Saving Word Placement State ---");
    const wordPlacements = {};
    const allWordItems = document.querySelectorAll('.word-item'); // Find all words in the DOM

    allWordItems.forEach(wordEl => {
        const parentZone = wordEl.closest('.drop-zone'); // Find the nearest ancestor drop zone
        let containerCategory = 'source'; // Default to word bank ('source')

        if (parentZone) {
            // Get category from zone's data attribute (should have original case)
            containerCategory = parentZone.dataset.category;
        } else {
             // This case should ideally not happen if elements are always within word-bank or a category drop-zone after init
             console.warn(`Word item "${wordEl.id}" has NO drop-zone parent! Defaulting to 'source'. Current parent:`, wordEl.parentElement);
        }
        // Store placement using the word's stable ID and the container's category name (original case)
        wordPlacements[wordEl.id] = containerCategory;
    });

    // console.log("Word placements to save:", wordPlacements); // Can be verbose

    try {
        const stateString = JSON.stringify(wordPlacements);
        localStorage.setItem(wordStateStorageKey, stateString);
        console.log(`Word placement state saved successfully.`);
    } catch (error) {
        console.error("!!! Failed to save word placement state to localStorage:", error);
        // Show error only on back side where user can see results area
        if (!isFront && resultsDiv) {
             resultsDiv.textContent = "Could not save progress (localStorage error).";
             resultsDiv.style.color = "var(--clr-results-error, red)";
             resultsDiv.style.display = '';
         }
    }
     console.log("--- End Saving Word Placement State ---");
}


function loadWordPlacementState() {
    // Loads the saved placement (category) for each word item ID.
    // Only runs on the back side. Column order should already be applied by initGame.
    if (isFront) return; // Don't load state on the front side

    console.log("--- Loading Word Placement State ---");
    const savedStateJSON = localStorage.getItem(wordStateStorageKey);

    if (!savedStateJSON) {
        console.log("No saved word placement state found.");
        console.log("--- End Loading Word Placement State ---");
        return; // Nothing to load
    }

    let savedPlacements;
    try {
        savedPlacements = JSON.parse(savedStateJSON);
    } catch (error) {
        console.error("Failed to parse saved word placement state from localStorage:", error);
         if (resultsDiv) { // Show error on back
             resultsDiv.textContent = "Could not load previous progress (parse error).";
             resultsDiv.style.color = "var(--clr-results-error, red)";
             resultsDiv.style.display = '';
         }
         localStorage.removeItem(wordStateStorageKey); // Clear corrupted state
         console.log("--- End Loading Word Placement State ---");
        return;
    }

    if (typeof savedPlacements !== 'object' || savedPlacements === null) {
        console.error("Invalid saved word placement state format:", savedPlacements);
        if (resultsDiv) {
             resultsDiv.textContent = "Could not load previous progress (invalid format).";
             resultsDiv.style.color = "var(--clr-results-error, red)";
             resultsDiv.style.display = '';
         }
         localStorage.removeItem(wordStateStorageKey); // Clear invalid state
         console.log("--- End Loading Word Placement State ---");
        return;
    }

    console.log("Applying loaded word placements...");
    let foundMismatch = false; // Flag if a word ID from state isn't in current DOM

    Object.keys(savedPlacements).forEach(wordId => {
        const wordEl = document.getElementById(wordId); // Find word element by its stable ID
        // Get saved category (should be original case if saved correctly)
        const targetCategory = savedPlacements[wordId];

        if (wordEl && targetCategory) {
            let targetContainer = null;
            if (targetCategory === 'source') {
                targetContainer = wordBank; // Target is the word bank
            } else {
                // Find the specific category drop zone using the original case category name
                targetContainer = document.querySelector(`.category-column .drop-zone[data-category="${targetCategory}"]`);
            }

            if (targetContainer) {
                 // Move the element only if it's not already in the correct container
                 if(wordEl.parentElement !== targetContainer) {
                      console.log(` - Moving item "${wordId}" to zone "${targetCategory}"`);
                      targetContainer.appendChild(wordEl);
                 } else {
                      // console.log(` - Item "${wordId}" already in correct zone "${targetCategory}"`); // Verbose
                 }
            } else {
                console.warn(`Target container NOT FOUND for category "${targetCategory}" (Item ID: ${wordId}). Leaving item where it is or placing in bank as fallback.`);
                foundMismatch = true; // Indicate something might be off
                 // As a robust fallback, try moving to word bank if it's not there already
                 if (wordEl.parentElement !== wordBank) {
                     wordBank.appendChild(wordEl);
                 }
            }
        } else {
            if (!wordEl) {
                console.warn(`Item element with ID "${wordId}" from saved state not found in current DOM. It might have been removed or changed in the template.`);
                foundMismatch = true;
            }
            if (!targetCategory) {
                 console.warn(`Invalid target category "${targetCategory}" for item ID "${wordId}" in saved state.`);
            }
        }
    });

    if (foundMismatch && resultsDiv) {
        // Optionally inform user if some saved state couldn't be applied
        // resultsDiv.textContent += " (Note: Some saved positions might not have been fully restored if card content changed.)";
        // resultsDiv.style.color = "var(--clr-results-info, blue)";
    }

    console.log("Word placement state load complete.");
    console.log("--- End Loading Word Placement State ---");
}


// --- Event Listeners & Initialization ---

// Add button listeners only if elements exist AND it's the back side
if (!isFront) {
    if (checkButton) checkButton.addEventListener('click', checkAnswers);
    if (showAnswerButton) showAnswerButton.addEventListener('click', showAnswers);
}

// --- Initialize and Load ---
// 1. Initialize the game structure.
//    - On FRONT: Parses input, creates elements, shuffles columns, SAVES column order.
//    - On BACK: Parses input, creates elements, LOADS column order (if available), builds columns in that order.
    function disableImageDragging() {
        const images = document.querySelectorAll('img');
        images.forEach(img => {
            img.draggable = false;
            // Optional: Add a class for styling or identification
            // img.classList.add('non-draggable-image');
        });
        // console.log(`Set draggable=false for ${images.length} image(s).`); // For debugging
    }

    // Call it once initially
    disableImageDragging();
initGame();

// 2. Load word placement state.
//    - Only runs on BACK side AFTER the structure (columns, words) exists.
//    - Moves words to their saved positions based on IDs and category names.
if (!isFront) {
    loadWordPlacementState();
    // Optional: Automatically check answers after loading state on the back?
    checkAnswers(); // Uncomment this line if you want immediate feedback on loaded state
}

})(); // End IIFE
</script>
</body>
</html> 
